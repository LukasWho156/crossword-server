/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/puzzle.ts":
/*!***********************!*\
  !*** ./src/puzzle.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _shared_puzzle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/puzzle */ \"./src/shared/puzzle.ts\");\n/* harmony import */ var _shared_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/settings */ \"./src/shared/settings.ts\");\n/* harmony import */ var _shared_404_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/404.json */ \"./src/shared/404.json\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst createErrorDiv = (message) => {\n    document.querySelector('.puzzleArea').removeChild(document.querySelector('.loadingZone'));\n    const div = document.createElement('div');\n    div.innerHTML = message;\n    document.querySelector('.puzzleArea').appendChild(div);\n};\nconst main = () => __awaiter(void 0, void 0, void 0, function* () {\n    const puzzleId = document.URL.split('/').at(-1);\n    const res = yield fetch(`/api/puzzle/${puzzleId}`).catch(e => {\n        createErrorDiv(\"Der Server antwortet nicht.\");\n    });\n    if (!res)\n        return;\n    let data = null;\n    switch (res.status) {\n        case 200:\n            data = yield res.json();\n            break;\n        case 404:\n            data = _shared_404_json__WEBPACK_IMPORTED_MODULE_2__;\n            break;\n        case 501:\n            createErrorDiv(\"Ein Server-Fehler ist aufgetreten.\");\n            return;\n        default:\n            createErrorDiv(\"Ein unbekannter Fehler ist aufgetreten.\");\n            return;\n    }\n    const crossword = new _shared_puzzle__WEBPACK_IMPORTED_MODULE_0__.Puzzle(data);\n    try {\n        const saveState = window.localStorage.getItem(`save-state-${puzzleId}`);\n        if (saveState) {\n            crossword.importState(saveState);\n        }\n    }\n    catch (e) {\n        console.warn('Error accessing local storage');\n    }\n    crossword.addEventListener('change', () => {\n        try {\n            window.localStorage.setItem(`save-state-${puzzleId}`, crossword.exportState());\n        }\n        catch (e) {\n            console.warn('Error accessing local storage');\n        }\n    });\n    if (data.title)\n        document.querySelector('h1').textContent = data.title;\n    document.querySelector('.puzzleArea').removeChild(document.querySelector('.loadingZone'));\n    document.querySelector('.puzzleArea').appendChild(crossword.render());\n    document.querySelector('.hintArea').appendChild(crossword.renderHintSection());\n    document.querySelector('#autocheck').addEventListener('change', (e) => {\n        if (e.target.checked) {\n            crossword.checkCells();\n            _shared_settings__WEBPACK_IMPORTED_MODULE_1__.Settings.autocheck = true;\n        }\n        else {\n            _shared_settings__WEBPACK_IMPORTED_MODULE_1__.Settings.autocheck = false;\n        }\n    });\n    document.querySelector('#check').addEventListener('click', crossword.checkCells);\n    document.querySelector('#restart').addEventListener('click', crossword.restart);\n    const wrongDialog = document.querySelector('#wrongAlert');\n    document.querySelector('#wrongAlert>button').addEventListener('click', () => wrongDialog.close());\n    const correctDialog = document.querySelector('#correctAlert');\n    document.querySelector('#correctAlert>button').addEventListener('click', () => correctDialog.close());\n    adjustCrosswordSize(crossword);\n    window.addEventListener('resize', () => adjustCrosswordSize(crossword));\n});\nconst findRuleIndex = (selector) => {\n    for (let i = 0; i < document.styleSheets[0].cssRules.length; i++) {\n        const rules = document.styleSheets[0].cssRules[i];\n        if (rules.cssText.includes(selector))\n            return i;\n    }\n    return -1;\n};\nconst adjustCrosswordSize = (puzzle) => {\n    const area = document.querySelector('.puzzleArea');\n    const cellSize = Math.max(30, Math.min(60, Math.min(area.clientWidth / puzzle.width, area.clientHeight / puzzle.height)));\n    const i = findRuleIndex('td.size');\n    if (i >= 0) {\n        document.styleSheets[0].deleteRule(i);\n        document.styleSheets[0].insertRule(`td.size { width: ${cellSize}px; height: ${cellSize}px; }`);\n    }\n    const j = findRuleIndex('input.size');\n    if (j >= 0) {\n        document.styleSheets[0].deleteRule(j);\n        document.styleSheets[0].insertRule(`input.size { font-size: ${cellSize * 0.75}px; }`);\n    }\n    const k = findRuleIndex('span.size');\n    if (k >= 0) {\n        document.styleSheets[0].deleteRule(k);\n        document.styleSheets[0].insertRule(`span.size { font-size: ${cellSize * 0.25}px; }`);\n    }\n};\nmain();\n\n\n//# sourceURL=webpack://kreuzwortraetsel/./src/puzzle.ts?");

/***/ }),

/***/ "./src/shared/cell.ts":
/*!****************************!*\
  !*** ./src/shared/cell.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cell\": () => (/* binding */ Cell)\n/* harmony export */ });\n/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings */ \"./src/shared/settings.ts\");\n\nconst LIGHT_OUTLINE = \"1px\";\nconst HEAVY_OUTLINE = \"3px\";\nclass Cell extends EventTarget {\n    get clueNumber() {\n        return this.clue;\n    }\n    get isClue() {\n        return !!this.clue;\n    }\n    get value() {\n        return this.input.value;\n    }\n    set value(v) {\n        this.input.value = v;\n    }\n    constructor(x, y, solution) {\n        super();\n        this.updateContents = (e) => {\n            const input = e.target;\n            if (e.inputType !== 'insertText') {\n                this.input.classList.remove('correct', 'wrong');\n                return;\n            }\n            if (!e.data.match(/^[A-Za-z]$/)) {\n                if (input.value.length > e.data.length) {\n                    input.value = input.value[0];\n                }\n                else {\n                    input.value = \"\";\n                }\n                return;\n            }\n            this.input.classList.remove('correct', 'wrong');\n            input.value = e.data.toUpperCase();\n            if (_settings__WEBPACK_IMPORTED_MODULE_0__.Settings.autocheck) {\n                this.check();\n            }\n            this.dispatchEvent(new CustomEvent('filled', { detail: { target: this } }));\n        };\n        this.onFocus = (e) => {\n            this.dispatchEvent(new CustomEvent('clicked', { detail: { target: this, repeated: false } }));\n        };\n        this.onBlur = () => {\n            this.dispatchEvent(new CustomEvent('blur', { detail: { target: this } }));\n        };\n        this.onMouseDown = () => {\n            if (document.activeElement === this.input) {\n                this.dispatchEvent(new CustomEvent('clicked', { detail: { target: this, repeated: true } }));\n            }\n        };\n        this.onMouseUp = () => {\n            this.dispatchEvent(new CustomEvent('mouseup', { detail: { target: this } }));\n        };\n        this.onMouseEnter = (e) => {\n            if ((e.buttons & 1) > 0) {\n                this.dispatchEvent(new CustomEvent('dragged', { detail: { target: this } }));\n            }\n        };\n        this.onKeyDown = (e) => {\n            if (e.code === 'Tab') {\n                e.preventDefault();\n                this.dispatchEvent(new CustomEvent('filled', { detail: { target: this } }));\n            }\n            if (e.code === 'Backspace' && this.input.value === '') {\n                e.preventDefault();\n                this.dispatchEvent(new CustomEvent('retract', { detail: { target: this } }));\n            }\n            if (e.code === 'ArrowLeft') {\n                e.preventDefault();\n                this.dispatchEvent(new CustomEvent('move', { detail: { target: this, targetX: this.x - 1, targetY: this.y } }));\n            }\n            if (e.code === 'ArrowRight') {\n                e.preventDefault();\n                this.dispatchEvent(new CustomEvent('move', { detail: { target: this, targetX: this.x + 1, targetY: this.y } }));\n            }\n            if (e.code === 'ArrowUp') {\n                e.preventDefault();\n                this.dispatchEvent(new CustomEvent('move', { detail: { target: this, targetX: this.x, targetY: this.y - 1 } }));\n            }\n            if (e.code === 'ArrowDown') {\n                e.preventDefault();\n                this.dispatchEvent(new CustomEvent('move', { detail: { target: this, targetX: this.x, targetY: this.y + 1 } }));\n            }\n        };\n        this.markAsClue = (clue) => {\n            this.clue = clue;\n        };\n        this.render = () => {\n            this.element.className = 'size';\n            this.element.style.borderWidth = HEAVY_OUTLINE;\n            if ((this.connections & 0b1) > 0) {\n                this.element.style.borderLeftWidth = LIGHT_OUTLINE;\n            }\n            if ((this.connections & 0b10) > 0) {\n                this.element.style.borderRightWidth = LIGHT_OUTLINE;\n            }\n            if ((this.connections & 0b100) > 0) {\n                this.element.style.borderTopWidth = LIGHT_OUTLINE;\n            }\n            if ((this.connections & 0b1000) > 0) {\n                this.element.style.borderBottomWidth = LIGHT_OUTLINE;\n            }\n            if (this.isClue) {\n                const clueSpan = document.createElement('span');\n                clueSpan.className = 'clue size';\n                clueSpan.innerHTML = this.clue.toFixed(0);\n                this.element.appendChild(clueSpan);\n            }\n            this.input.setAttribute('type', 'text');\n            this.input.setAttribute('autocomplete', 'off');\n            this.input.className = 'size';\n            this.input.addEventListener('mousedown', this.onMouseDown);\n            this.input.addEventListener('mouseup', this.onMouseUp);\n            this.input.addEventListener('mouseenter', this.onMouseEnter);\n            this.input.addEventListener('focus', this.onFocus);\n            this.input.addEventListener('blur', this.onBlur);\n            this.input.addEventListener('input', this.updateContents);\n            this.input.addEventListener('keydown', this.onKeyDown);\n            this.element.appendChild(this.input);\n            return this.element;\n        };\n        this.addConnection = (c) => {\n            this.connections += c;\n        };\n        this.resetConnections = () => {\n            this.connections = 0;\n        };\n        this.focus = () => {\n            this.input.focus();\n        };\n        this.clear = () => {\n            this.input.classList.remove('correct', 'wrong');\n            this.input.value = '';\n        };\n        this.select = () => {\n            this.input.classList.add('selected');\n        };\n        this.deselect = () => {\n            this.input.classList.remove('selected');\n        };\n        this.check = () => {\n            if (!this.isFilled) {\n                this.input.classList.remove('correct', 'wrong');\n                return;\n            }\n            if (this.isCorrect) {\n                this.input.classList.add('correct');\n            }\n            else {\n                this.input.classList.add('wrong');\n            }\n        };\n        this.x = x;\n        this.y = y;\n        this.solution = solution;\n        this.connections = 0;\n        this.element = document.createElement('td');\n        this.input = document.createElement('input');\n    }\n    get isFilled() {\n        return this.input.value.length > 0;\n    }\n    get isCorrect() {\n        return this.input.value === this.solution;\n    }\n}\n\n\n\n//# sourceURL=webpack://kreuzwortraetsel/./src/shared/cell.ts?");

/***/ }),

/***/ "./src/shared/puzzle.ts":
/*!******************************!*\
  !*** ./src/shared/puzzle.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Puzzle\": () => (/* binding */ Puzzle)\n/* harmony export */ });\n/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cell */ \"./src/shared/cell.ts\");\n/* harmony import */ var _word__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./word */ \"./src/shared/word.ts\");\n\n\nclass Puzzle extends EventTarget {\n    constructor(data) {\n        super();\n        this.alertOpened = false;\n        this.render = () => {\n            const table = document.createElement('table');\n            for (let y = 0; y < this.height; y++) {\n                const row = document.createElement('tr');\n                table.appendChild(row);\n                for (let x = 0; x < this.width; x++) {\n                    const cell = this.findCell(x, y);\n                    if (cell) {\n                        row.appendChild(cell.render());\n                    }\n                    else {\n                        row.appendChild(document.createElement('td'));\n                    }\n                }\n            }\n            return table;\n        };\n        this.renderHintSection = () => {\n            const section = document.createElement('div');\n            section.className = 'hintSection';\n            if (this.horizontalWords.length > 0) {\n                const heading = document.createElement('div');\n                heading.className = 'hintHeading';\n                heading.innerHTML = 'Horizontal:';\n                section.appendChild(heading);\n                for (const w of this.horizontalWords) {\n                    w.addEventListener('selected', (e) => this.selectWord(w, true));\n                    section.appendChild(w.renderHint());\n                }\n            }\n            if (this.verticalWords.length > 0) {\n                const heading = document.createElement('div');\n                heading.className = 'hintHeading';\n                heading.innerHTML = 'Vertikal:';\n                section.appendChild(heading);\n                for (const w of this.verticalWords) {\n                    w.addEventListener('selected', (e) => this.selectWord(w, true));\n                    section.appendChild(w.renderHint());\n                }\n            }\n            return section;\n        };\n        this.findCell = (x, y) => {\n            for (const cell of this.cells) {\n                if (cell.x === x && cell.y === y) {\n                    return cell;\n                }\n            }\n            return null;\n        };\n        this.onCellClick = (e) => {\n            let hContainer;\n            let vContainer;\n            for (const w of this.horizontalWords) {\n                if (w.containsCell(e.detail.target)) {\n                    hContainer = w;\n                }\n            }\n            for (const w of this.verticalWords) {\n                if (w.containsCell(e.detail.target)) {\n                    vContainer = w;\n                }\n            }\n            if (this.mode === 'h' || !this.mode) {\n                if (hContainer) {\n                    if (hContainer === this.curWord) {\n                        if (vContainer && e.detail.repeated) {\n                            this.selectWord(vContainer);\n                        }\n                    }\n                    else {\n                        this.selectWord(hContainer);\n                    }\n                }\n                else if (vContainer) {\n                    this.selectWord(vContainer);\n                }\n            }\n            else {\n                if (vContainer) {\n                    if (vContainer === this.curWord) {\n                        if (hContainer && e.detail.repeated) {\n                            this.selectWord(hContainer);\n                        }\n                    }\n                    else {\n                        this.selectWord(vContainer);\n                    }\n                }\n                else if (hContainer) {\n                    this.selectWord(hContainer);\n                }\n            }\n        };\n        this.selectWord = (word, selectFirstCell) => {\n            if (this.curWord)\n                this.curWord.deselect();\n            this.curWord = word;\n            this.mode = word.direction;\n            word.select(selectFirstCell);\n        };\n        this.advance = (e) => {\n            this.dispatchEvent(new CustomEvent('change'));\n            if (!this.curWord)\n                return;\n            if (!this.curWord.advance(e.detail.target)) {\n                if (this.mode === 'h') {\n                    const i = this.horizontalWords.findIndex(w => w === this.curWord);\n                    if (i === this.horizontalWords.length - 1) {\n                        this.selectWord(this.verticalWords[0], true);\n                    }\n                    else {\n                        this.selectWord(this.horizontalWords[i + 1], true);\n                    }\n                }\n                else {\n                    const i = this.verticalWords.findIndex(w => w === this.curWord);\n                    if (i === this.verticalWords.length - 1) {\n                        this.selectWord(this.horizontalWords[0], true);\n                    }\n                    else {\n                        this.selectWord(this.verticalWords[i + 1], true);\n                    }\n                }\n            }\n            this.checkForCompletition();\n        };\n        this.retract = (e) => {\n            this.dispatchEvent(new CustomEvent('change'));\n            if (!this.curWord)\n                return;\n            this.curWord.retract(e.detail.target);\n        };\n        this.move = (e) => {\n            const cell = this.findCell(e.detail.targetX, e.detail.targetY);\n            if (cell)\n                cell.focus();\n        };\n        this.restart = () => {\n            for (const cell of this.cells) {\n                cell.clear();\n            }\n        };\n        this.checkCells = () => {\n            for (const cell of this.cells) {\n                cell.check();\n            }\n        };\n        this.exportState = () => {\n            return this.cells.reduce((prev, cur) => {\n                if (!cur.isFilled) {\n                    return prev + '.';\n                }\n                return prev + cur.value;\n            }, '');\n        };\n        this.importState = (state) => {\n            if (state.length != this.cells.length) {\n                return;\n            }\n            if (state.match(/^[A-Z\\.]*$/).length === 0) {\n                return;\n            }\n            this.cells.forEach((cell, i) => {\n                const letter = state[i];\n                if (letter === '.') {\n                    cell.clear();\n                    return;\n                }\n                cell.value = letter;\n            });\n        };\n        this.width = data.width;\n        this.height = data.height;\n        this.cells = [];\n        for (let x = 0; x < data.width; x++) {\n            for (let y = 0; y < data.height; y++) {\n                if (data.solution[y][x].match(/[A-Z]/)) {\n                    this.cells.push(new _cell__WEBPACK_IMPORTED_MODULE_0__.Cell(x, y, data.solution[y][x]));\n                }\n            }\n        }\n        this.horizontalWords = [];\n        this.verticalWords = [];\n        let curClue = 1;\n        for (let y = 0; y < data.height; y++) {\n            for (let x = 0; x < data.width; x++) {\n                const cell = this.findCell(x, y);\n                if (!cell)\n                    continue;\n                cell.addEventListener('clicked', this.onCellClick);\n                cell.addEventListener('filled', this.advance);\n                cell.addEventListener('retract', this.retract);\n                cell.addEventListener('move', this.move);\n                cell.addEventListener('blur', () => {\n                    if (this.curWord) {\n                        this.curWord.deselect();\n                        this.curWord = null;\n                    }\n                });\n                const hWord = data.clues.horizontal.find(w => w.x === x && w.y === y);\n                const vWord = data.clues.vertical.find(w => w.x === x && w.y === y);\n                if (hWord || vWord) {\n                    cell.markAsClue(curClue);\n                    if (hWord) {\n                        this.horizontalWords.push(new _word__WEBPACK_IMPORTED_MODULE_1__.Word(this, curClue, hWord, 'h'));\n                    }\n                    if (vWord) {\n                        this.verticalWords.push(new _word__WEBPACK_IMPORTED_MODULE_1__.Word(this, curClue, vWord, 'v'));\n                    }\n                    curClue++;\n                }\n            }\n        }\n    }\n    checkForCompletition() {\n        for (const cell of this.cells) {\n            if (!cell.isFilled)\n                return;\n        }\n        for (const cell of this.cells) {\n            if (!cell.isCorrect) {\n                if (!this.alertOpened) {\n                    document.querySelector('#wrongAlert').showModal();\n                    this.alertOpened = true;\n                }\n                return;\n            }\n        }\n        document.querySelector('#correctAlert').showModal();\n    }\n}\n\n\n\n//# sourceURL=webpack://kreuzwortraetsel/./src/shared/puzzle.ts?");

/***/ }),

/***/ "./src/shared/settings.ts":
/*!********************************!*\
  !*** ./src/shared/settings.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Settings\": () => (/* binding */ Settings)\n/* harmony export */ });\nconst Settings = {\n    autocheck: false,\n};\n\n\n\n//# sourceURL=webpack://kreuzwortraetsel/./src/shared/settings.ts?");

/***/ }),

/***/ "./src/shared/word.ts":
/*!****************************!*\
  !*** ./src/shared/word.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Word\": () => (/* binding */ Word)\n/* harmony export */ });\nclass Word extends EventTarget {\n    constructor(puzzle, clue, data, direction) {\n        super();\n        this.initCells = (puzzle, startX, startY, dir, length) => {\n            this.cells = [];\n            for (let i = 0; i < length; i++) {\n                const x = startX + (dir === 'h' ? i : 0);\n                const y = startY + (dir === 'v' ? i : 0);\n                const cell = puzzle.findCell(x, y);\n                this.cells.push(cell);\n                if (i > 0) {\n                    cell.addConnection(dir === 'h' ? 0b1 : 0b100);\n                }\n                if (i < length - 1) {\n                    cell.addConnection(dir === 'h' ? 0b10 : 0b1000);\n                }\n            }\n        };\n        this.renderHint = () => {\n            this.hintDiv.className = 'clue';\n            this.hintDiv.textContent = `${this.number}: ${this.desc}`;\n            this.hintDiv.addEventListener('mousedown', this.onClick);\n            this.hintDiv.addEventListener('contextmenu', this.onContextMenu);\n            return this.hintDiv;\n        };\n        this.onClick = () => {\n            setTimeout(() => this.dispatchEvent(new CustomEvent('selected', { detail: { word: this } })));\n        };\n        this.onContextMenu = (e) => {\n            e.preventDefault();\n            this.dispatchEvent(new CustomEvent('rightclicked', { detail: { word: this } }));\n        };\n        this.containsCell = (cell) => {\n            for (const c of this.cells) {\n                if (c === cell) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        this.select = (focusFirstCell) => {\n            this.hintDiv.classList.add('selected');\n            for (const c of this.cells) {\n                c.select();\n            }\n            if (focusFirstCell) {\n                this.cells[0].focus();\n            }\n        };\n        this.deselect = () => {\n            this.hintDiv.classList.remove('selected');\n            for (const c of this.cells) {\n                c.deselect();\n            }\n        };\n        this.advance = (curCell) => {\n            const i = this.cells.findIndex(c => c === curCell);\n            if (i < 0)\n                return false;\n            if (i === this.cells.length - 1) {\n                return false;\n            }\n            this.cells[i + 1].focus();\n            return true;\n        };\n        this.retract = (curCell) => {\n            const i = this.cells.findIndex(c => c === curCell);\n            if (i < 0)\n                return false;\n            if (i === 0) {\n                return false;\n            }\n            this.cells[i - 1].clear();\n            this.cells[i - 1].focus();\n            return true;\n        };\n        this.wordData = data;\n        this.number = clue;\n        this.desc = data.clue;\n        this.direction = direction;\n        this.cells = [];\n        if (puzzle)\n            this.initCells(puzzle, data.x, data.y, direction, data.length);\n        this.hintDiv = document.createElement('div');\n    }\n}\n\n\n\n//# sourceURL=webpack://kreuzwortraetsel/./src/shared/word.ts?");

/***/ }),

/***/ "./src/shared/404.json":
/*!*****************************!*\
  !*** ./src/shared/404.json ***!
  \*****************************/
/***/ ((module) => {

eval("module.exports = JSON.parse('{\"title\":\"404 - Rätsel Nicht Gefunden\",\"width\":9,\"height\":5,\"solution\":[\"N.FOUND.S\",\"O.LS.AI.A\",\"TRUT.REIM\",\"..RE.B..B\",\"..ENTE..A\"],\"clues\":{\"horizontal\":[{\"x\":2,\"y\":0,\"length\":5,\"clue\":\"Lost and _____\"},{\"x\":2,\"y\":1,\"length\":2,\"clue\":\"Zeigt Penguinen den Inhalt eines Ordners an.\"},{\"x\":5,\"y\":1,\"length\":2,\"clue\":\"Nicht wirklich intelligent, aber definitiv künstlich (engl.).\"},{\"x\":0,\"y\":2,\"length\":4,\"clue\":\"In diesem Hahn steckt fast die Wahrheit.\"},{\"x\":5,\"y\":2,\"length\":4,\"clue\":\"Schleim und Keim und dieses Wort.\"},{\"x\":2,\"y\":3,\"length\":2,\"clue\":\"Kein Wochentag, liegt aber trotzdem zwischen Do und Mi.\"},{\"x\":2,\"y\":4,\"length\":4,\"clue\":\"In diesem Vogel steckt definitv keine Wahrheit.\"}],\"vertical\":[{\"x\":0,\"y\":0,\"length\":3,\"clue\":\"Macht aus wahr falsch und aus falsch wahr.\"},{\"x\":2,\"y\":0,\"length\":5,\"clue\":\"Gänge\"},{\"x\":3,\"y\":0,\"length\":5,\"clue\":\"Gegenüber gibt es nichts Neues.\"},{\"x\":5,\"y\":0,\"length\":5,\"clue\":\"Was übrig bleiben kann, nachdem die Zeit ihren Job gemacht hat.\"},{\"x\":6,\"y\":0,\"length\":3,\"clue\":\"Auf Deutsch deutlich harmloser als auf Englisch.\"},{\"x\":8,\"y\":0,\"length\":5,\"clue\":\"Ermöglicht es Windows, mit anderen Betriebssystemen zu tanzen.\"}]}}');\n\n//# sourceURL=webpack://kreuzwortraetsel/./src/shared/404.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/puzzle.ts");
/******/ 	
/******/ })()
;